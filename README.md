# Python面试常见算法解题

## Offer50
剑指Offer50题, 以LintCode上的题目为准;

### 1 FizzBuzz问题

这道题需要注意的是: 优先判断是否既是 3 的倍数, 同时又是 5 的倍数, 即能否被 15 整除;

### 2 斐波那契数列

* 简单递归: 不使用记忆化方法, 时间复杂度为O(n^2);
* 记忆化递归: 只需要保存 f(n-1) 和 f(n-2), 时间复杂度降为 O(n);
* 递推公式: O(logN), 主要是计算 n 次幂消耗的时间;

### 3 单例

Python中的单例实现可以总结为以下几种方式:

* 类装饰器;
* 修改 `__new__`;
* 使用元类;
* 使用模块;
* 修改类的 `__dict__`;

### 4 替换空格

从后向前遍历, 遇到空格, 再从后向前复制前一个字符;

### 5 二进制中 1 的个数

使用 `n & (n-1)` 来将最后一位的1清零

例如:

`6`的二进制为: `110`
`5`的二进制为: `101`
`4`的二进制为: `100`
`3`的二进制为: `011`

`6 & 5` 的结果为 `100` 是 `4`, `6 & 5 & 3` 的结果是 `0`, 这时已经没有 1在二进制结果中;

这里需要注意 Python 中的二进制是有符号的, 所以需要单独处理:

`-1`在Python中的二进制为: `-0b1`而不是`(10)`

### 6 翻转单链表

链表操作最重要的是要注意边界条件和指针丢失的问题;

### 7 寻找旋转排序数组中的最小值

除了常规的边界条件检测之外, 可以将旋转排序数组区分为两个有序递增数组, 例如:
数组`[4, 5, 6, 7, 0, 1, 2]`, 可以分为 `[4, 5, 6, 7]` 和 `[0, 1, 2]`
利用二分查找法, 如果 mid 落在前半个区间, 那么最小值一定在右侧; 如果落在后半个区间, 那么最小值在左侧;
而判断落在哪个区间的方法就是跟数组的第一个元素比较;

### 8 利用前序和中序遍历结果构造二叉树

利用遍历结果构造二叉树的关键在于找到根节点元素的位置;

### 9 利用栈实现队列

利用两个栈和其FILO的特性, 实现队列的FIFO的特性;

### 10 搜索二维矩阵

可以使用两次二分查找:

1. 第一次二分查找找到目标值可能位于的行;
2. 第二次二分查找搜索该行中是否存在目标值;

所以时间复杂度是O(lgM * lgN)

### 11 搜索二维矩阵II

这道题与上一题的区别在于没有每一行最后一个元素大于下一行第一个元素的约束条件, 所以无法使用二分查找直接搜索目标;

这里使用夹逼的方式进行查找, 从矩阵的左下角向右上角进行夹逼;